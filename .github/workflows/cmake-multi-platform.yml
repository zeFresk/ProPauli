# This is a basic GitHub Actions workflow to build and test a C++ CMake project.
#
# It defines a single job, "build_and_test", that runs on a matrix of operating systems.
# For each OS, it checks out the code, configures the CMake project in Debug mode
# with sanitizers and tests enabled, builds the project, and then runs the tests.

name: C++ CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push events but only for the "main" branch
  push:
    branches: [ "main" ]
  # Triggers the workflow on pull request events for the "main" branch
  pull_request:
    branches: [ "main" ]

permissions:
  checks: write
  # The pull-requests: write permission is required for this action to be able
  # to comment on pull requests, which it does by default.
  pull-requests: write

jobs:
  build_and_test:
    # The type of runner that the job will run on
    # We use a strategy matrix to run the job on multiple operating systems.
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}

    # Sets the C and C++ compilers to clang for this job
    env:
      CC: clang
      CXX: clang++

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Step 1: Check out the repository under $GITHUB_WORKSPACE, so the job can access it
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Install dependencies.
      # On Ubuntu, we install clang and cmake via apt-get.
      # On macOS, we install the latest version of clang (llvm) via Homebrew.
      - name: Install dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y clang cmake

      - name: Install latest Clang (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install llvm cmake
          echo "$(brew --prefix llvm)/bin" >> $GITHUB_PATH


      - name: Debug
        run: |
          cmake --version
          clang++ --version

      # Step 3: Configure CMake
      # This step creates a 'build' directory and runs cmake to generate the build files.
      # - CMAKE_BUILD_TYPE=Debug: Specifies a debug build.
      # - SANITIZE=ON: A custom option to enable sanitizers (AddressSanitizer, UndefinedBehaviorSanitizer).
      # - TEST=ON: A custom option to enable building tests.
      - name: Configure CMake
        run: >
          cmake -S . -B build
          -D CMAKE_BUILD_TYPE=Debug
          -D SANITIZE=ON
          -D TEST=ON

      # Step 4: Build the project
      # This step compiles the source code using the generated build files.
      # The --config flag is technically redundant here since we set the build type
      # in the configure step, but it's good practice for multi-configuration generators.
      - name: Build project
        run: cmake --build build --config Debug

      - name: Run CTest and Generate Report
        working-directory: ./build
        run: ctest -C Debug --verbose --output-on-failure --output-junit Test.xml || true

      # This step parses the Test.xml file and creates a detailed summary
      # in the "Checks" tab of the workflow run.
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: runner.os == 'Linux' 
        with:
          files: build/Test.xml


  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    needs: build_and_test
    env:
      CC: clang
      CXX: clang++

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y clang

      - name: Configure CMake for Coverage
        run: >
          cmake -S . -B build
          -D CMAKE_BUILD_TYPE=Debug
          -D COVERAGE=ON 
          -D TEST=ON

      - name: Build project
        run: cmake --build build --config Debug

      - name: Run tests to generate coverage data
        working-directory: ./build
        run: ctest -C Debug --output-on-failure

      - name: Generate Coverage Report
        working-directory: ./build
        run: |
          # This assumes your test executable is named 'UnitTest'. 
          # If it has a different name, please change it here.
          TEST_EXECUTABLE=UnitTest
          
          if [ ! -f "$TEST_EXECUTABLE" ]; then
            echo "Error: Test executable '$TEST_EXECUTABLE' not found in build directory."
            echo "Please update the TEST_EXECUTABLE variable in the workflow."
            exit 1
          fi
          
          # Use llvm-profdata to merge the raw coverage data.
          llvm-profdata merge -sparse default.profraw -o default.profdata
          
          # Use llvm-cov to export the data in lcov format for Coveralls.
          # This command creates the coverage.info file.
          llvm-cov export -format=lcov "$TEST_EXECUTABLE" -instr-profile=default.profdata > coverage.info

      - name: Upload to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path-to-lcov: ./build/coverage.info

  benchmark:
    name: Run Google C++ Benchmark Framework example
    runs-on: ubuntu-latest
    needs: build_and_test
    env:
      CC: clang
      CXX: clang++
    steps:
      - uses: actions/checkout@v4
      - name: Cache Benchmark library
        uses: actions/cache@v4
        with:
          path: examples/cpp/benchmark
          key: ${{ runner.os }}-googlebenchmark-v1.5.0

      - name: Install dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y clang cmake

      - name: Configure CMake
        run: >
          cmake -S . -B build
          -D CMAKE_BUILD_TYPE=Release
          -D SANITIZE=OFF
          -D TEST=OFF
          -D BENCHMARK=ON

      - name: Build project
        run: cmake --build build --config Release
      
      - name: Run benchmark 
        run: ./build/Benchmark --benchmark_format=json | tee benchmark_result.json

      - name: Store benchmark result
        uses: benchmark-action/github-action-benchmark@v1
        with:
          name: C++ Benchmark
          tool: 'googlecpp'
          output-file-path: examples/cpp/benchmark_result.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true
          # Show alert with commit comment on detecting possible performance regression
          alert-threshold: '200%'
          comment-on-alert: true
          fail-on-alert: true
          alert-comment-cc-users: '@ktrz'

      - name: Store benchmark result - separate results repo
        uses: benchmark-action/github-action-benchmark@v1
        with:
          name: C++ Benchmark
          tool: 'googlecpp'
          output-file-path: examples/cpp/benchmark_result.json
          github-token: ${{ secrets.BENCHMARK_ACTION_BOT_TOKEN }}
          auto-push: true
          # Show alert with commit comment on detecting possible performance regression
          alert-threshold: '200%'
          comment-on-alert: true
          fail-on-alert: true
          alert-comment-cc-users: '@ktrz'
          gh-repository: 'github.com/benchmark-action/github-action-benchmark-results'
